{
  "items": {
    "lb-18or": {
      "id": "lb-18or",
      "title": "Fix 4 clippy warnings",
      "description": "cargo clippy reports 4 warnings: (1) collapsible if in store.rs:285, (2) uninlined format arg in main.rs:410, (3) unnecessary map_or in main.rs:625 (use is_some_and), (4) print literal in main.rs:738. Run cargo clippy --fix or apply manually.",
      "item_type": "task",
      "status": "closed",
      "priority": 2,
      "created_at": "2026-02-28T02:15:08.947148861Z",
      "updated_at": "2026-02-28T13:43:27.243730270Z"
    },
    "lb-4ttg": {
      "id": "lb-4ttg",
      "title": "Add push retry logic to unclaim command",
      "description": "The claim command (main.rs:372-407) has retry-on-push-conflict logic (fetch, check for claim conflict, merge, re-push), but unclaim (main.rs:429) just fails on push error. Add similar retry/merge logic for unclaim so it handles concurrent modifications gracefully.",
      "item_type": "task",
      "status": "open",
      "priority": 2,
      "claimed_by": "Mike Daum",
      "created_at": "2026-02-28T02:15:08.932817831Z",
      "updated_at": "2026-02-28T13:43:40.629120039Z"
    },
    "lb-61mu": {
      "id": "lb-61mu",
      "title": "Fix column alignment mismatch between print_list_header and print_list_row",
      "description": "print_list_header uses {:<12} for STATUS column but print_list_row uses {:<14} because 'open (claimed)' is 14 chars. This causes column misalignment whenever claimed items appear in the output. Fix by making both use {:<14} (or abbreviate the claimed indicator to fit in 12).",
      "item_type": "task",
      "status": "closed",
      "priority": 0,
      "created_at": "2026-02-28T02:15:08.874967769Z",
      "updated_at": "2026-02-28T02:30:49.833445869Z"
    },
    "lb-830f": {
      "id": "lb-830f",
      "title": "Code review findings",
      "description": "Collection of issues found during comprehensive code review of the litebrite codebase",
      "item_type": "epic",
      "status": "open",
      "priority": 1,
      "created_at": "2026-02-28T02:14:50.363279727Z",
      "updated_at": "2026-02-28T02:14:50.363279727Z"
    },
    "lb-953v": {
      "id": "lb-953v",
      "title": "Add mechanism to clear description in update command",
      "description": "The update command can set a description with -d/--description but cannot clear it back to None. Passing --description '' sets Some(\"\") not None. Add a --no-description flag or treat empty string as a clear signal.",
      "item_type": "task",
      "status": "open",
      "priority": 2,
      "created_at": "2026-02-28T02:15:08.918457159Z",
      "updated_at": "2026-02-28T02:15:08.918457159Z"
    },
    "lb-grsl": {
      "id": "lb-grsl",
      "title": "Fix tree view hiding children of filtered-out roots",
      "description": "In --tree mode (main.rs print_tree_item), if a root item is filtered out by should_show (e.g. it's closed and --all isn't set), all its descendants are invisible even if they individually pass the filter. The tree walk starts at roots and skips filtered ones entirely. Fix: when a root is filtered out, still walk its children to see if any pass the filter, promoting them to display as pseudo-roots.",
      "item_type": "task",
      "status": "closed",
      "priority": 1,
      "created_at": "2026-02-28T02:15:08.881466091Z",
      "updated_at": "2026-02-28T02:34:53.603209167Z"
    },
    "lb-hhip": {
      "id": "lb-hhip",
      "title": "Add cycle detection for parent relationships",
      "description": "set_parent (store.rs:158) prevents self-parenting but not transitive cycles (A parent of B, B parent of A). This would corrupt tree display with infinite recursion in print_tree_item. Add ancestor walk check before accepting a new parent relationship.",
      "item_type": "task",
      "status": "closed",
      "priority": 1,
      "created_at": "2026-02-28T02:15:08.896492742Z",
      "updated_at": "2026-02-28T02:36:06.164529829Z"
    },
    "lb-lktz": {
      "id": "lb-lktz",
      "title": "Add cycle detection for blocking dependencies",
      "description": "add_blocking_dep (store.rs:127) checks for self-blocks but not transitive cycles. Creating A blocks B, B blocks C, C blocks A is allowed and causes all three to be permanently blocked by ready_items. Add reachability check before inserting a new blocking dep to prevent cycles.",
      "item_type": "task",
      "status": "closed",
      "priority": 1,
      "created_at": "2026-02-28T02:15:08.887909342Z",
      "updated_at": "2026-02-28T02:37:19.001848997Z"
    },
    "lb-lztk": {
      "id": "lb-lztk",
      "title": "Warn or cascade on delete of item with children",
      "description": "delete_item (store.rs:82) removes the item and its deps but silently orphans any children (their parent dep is removed since it references the deleted item, making them new roots). Consider either: (a) recursively deleting children, (b) printing a warning listing orphaned children, or (c) requiring --force if children exist.",
      "item_type": "task",
      "status": "open",
      "priority": 2,
      "created_at": "2026-02-28T02:15:08.906267250Z",
      "updated_at": "2026-02-28T02:15:08.906267250Z"
    }
  },
  "deps": [
    {
      "from_id": "lb-61mu",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-grsl",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-lktz",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-hhip",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-lztk",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-953v",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-4ttg",
      "to_id": "lb-830f",
      "dep_type": "parent"
    },
    {
      "from_id": "lb-18or",
      "to_id": "lb-830f",
      "dep_type": "parent"
    }
  ]
}